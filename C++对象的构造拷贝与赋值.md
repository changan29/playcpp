### 构造、拷贝及赋值

除了定义类的对象如何初始化之外，类还需要控制 拷贝，复制和销毁对象是发生的行为，对象在几种情况下会被拷贝，如我们初始化变量以及以值得方式传递或返回一个对象，当我们使用赋值运算符时会发生赋值操作。

如果我们不主动定义这些操作，则编译器将会替我们合成他们，一般来说，编译器生成的版本将对象的每个成员进行拷贝、赋值和销毁操作。但是有的时候之前 浅层拷贝是有问题（参考浅拷贝和深拷贝）。

### default constructor 默认构造
类通过一个特殊的构造函数来控制默认初始化的过程，这个函数叫做默认构造函数。我们的类没有显示的定义一个构造函数，那么编译器就会为我们隐式的定义一个默认构造函数。

在 C++ 11中，如果我们需要默认的行为，那么可以通过在参数列表后面加上 = default 要求编译器生成构造函数。

```
MyClass( )  = default ;  
```

#### 构造函数初始值列表

```
MyBook( const string & s, double p) : bookNo(s) , price(p)  {} 
```

如果成员是 const或者引用的话，构造函数的初始值是必不可少的

```
class ConstRef{
public:
    ConstRef(int ii);
private:
    int i;
    const int ci;
    int &ri;
}

ConstRef::ConstRef(int ii): i(ii), ci(ii) , ri(i) { }
```

### 隐式的类类型转换


```
MyBook( const string & s) : bookNo(s)  {    ....    }
xxx.combine(MyBook bb ) { }
```
在 combine的 传参中，是可以给  string("999-0-99")这样的参数的，它会隐式的转换成 MyBook类，把这种构造函数称为 转换构造函数，这种类 类型的转换只能有一步，多了编译器不能解析。

抑制构造函数定义的隐式转换

```
explicit MyBook( const string & s) : bookNo(s)  {    ....    }
```

### 拷贝控制
当定义一个类的时候，我们显示地或是隐式的制定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：

- 拷贝构造函数
- 拷贝赋值运算符
- 移动构造函数
- 移动赋值运算符
- 析构函数

拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么；拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。

#### 拷贝构造函数

不论我们是否定义了其他构造函数，编译器都会为我们合成一个拷贝构造函数，合成的拷贝构造函数一般会将参数逐个拷贝到正在创建的对象中。

```
string  dots(10 , '.');         // 直接初始化
string  s(dots);                // 直接初始化
string  s2 = dots;              // 拷贝初始化
string  null_book = "99-09"     // 拷贝初始化
string  nines = string(10,'9'); // 拷贝初始化
```

拷贝初始化通常使用拷贝构造函数来完成，但是如果一个类有移动构造函数，则拷贝初始化使用移动构造函数而非构造构造拷贝函数。拷贝初始化不仅在我们 用 = 定义变量时会发生，在下列情况也会发生：

- 将一个对象作为实参传递给 非引用类型的形参
- 返回类型为非应用类型的函数返回一个对象


#### 拷贝赋值运算符

```
Book  b1 , b2;
b2 = b1;    // 拷贝赋值运算符
```
如果一个类没有定义自己的拷贝赋值运算符，编译器会为他生成拷贝赋值运算符，类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止改类型对象的赋值。


### 对象移动
移动对象在旧的版本是没有的，C++ 11后 可以使用, 这部分先做了解，基本没遇到

#### 右值引用
右值引用有一个很重要的性质:只能绑定到一个将要销毁的对象

```
int i = 42;
int && rr = i;      // 错误, 不能将一个右值引用绑定到 一个左值上 
int && rr2  = i * 42;   // 正确，将 右值绑定到 乘法结果上
int && rr3 = std::move(i); // 使用 move将 左值变为右值
```

#### 移动构造函数和移动赋值运算符

类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用，不同于拷贝构造函数，这个引用在移动构造函数中是一个右值引用。
```
StrVec::StrVec(StrVec && s) noexcept 
            : elements(s.elements) , first_free(s.first_free)
            {
                s.elements = s.first_free = NULL;
            }
```












